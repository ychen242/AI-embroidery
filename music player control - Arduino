float a = 0.0;
float b = 0.0;
const float voltageThreshold = 0.00001;
float qn1 = 0;
float wn1 = 0;
float an1 = 0;
float bn1 = 0;

float cn1 = 0;
float dn1 = 0;
float fn1 = 0;
float gn1 = 0;
const int numSamples = 1500;
int samplesRead = numSamples;
int samplesRead1 = numSamples;
const int numReadings = 10;
const int numReadings1 = 10;


int readingsIndex = 0;
float sumReadings = 0.0;

float readings[numReadings1];
int readingsIndex1 = 0;
float sumReadings1 = 0.0;

void setup() {
  Serial.begin(115200);
  while (!Serial);
 
}

void loop() {
  // Wait for significant motion
  while (samplesRead == numSamples) {
    float i = analogRead(A2) -10;
    float t = analogRead(A5)  ;
    float j = analogRead(A0) ;
    float k = analogRead(A7) ;
 
    float an = (i * 3.3 *10) / 1024.0;
    float bn = (t * 3.3 *10) / 1024.0;
    float qn = 0.969 * qn1 + 0.0155 * an + 0.0155 * an1;
    float wn = 0.969 * wn1 + 0.0155 * bn + 0.0155 * bn1;

    float cn = (j * 3.3 * 10) / 1024.0;
    float dn = (k * 3.3 * 10) / 1024.0;
    float fn = 0.969 * fn1 + 0.0155 * cn + 0.0155 * cn1;
    float gn = 0.969 * gn1 + 0.0155 * dn + 0.0155 * dn1;


    an1 = an;
    qn1 = qn;
    bn1 = bn;
    wn1 = wn;
    float xn = qn - wn;

    cn1 = cn;
    dn1 = dn;
    fn1 = fn;
    gn1 = gn;
    float hn = fn - gn;

    if (fabs(xn) > voltageThreshold) {
      // Reset the sample read count
      samplesRead = 0;
      break;
    }
  }

  // Collect and average samples
  while (samplesRead < numSamples) {
    delay(1);
    float i = analogRead(A3) -10;
    float t = analogRead(A6) ;
    float j = analogRead(A0) ;
    float k = analogRead(A7) ;

    float an = ((i * 3.3*10) / 1024.0) ;
    float bn = ((t * 3.3*10 ) / 1024.0) ;
    float qn = 0.969 * qn1 + 0.0155 * an + 0.0155 * an1;
    float wn = 0.969 * wn1 + 0.0155 * bn + 0.0155 * bn1 ;

    float cn = ((j * 3.3 * 10) / 1024.0) ;
    float dn = (k * 3.3 * 10) / 1024.0;
    float fn = 0.969 * fn1 + 0.0155 * cn + 0.0155 * cn1;
    float gn = 0.969 * gn1 + 0.0155 * dn + 0.0155 * dn1;

    an1 = an;
    qn1 = qn;
    bn1 = bn;
    wn1 = wn;
    float xn = qn - wn;

    cn1 = cn;
    dn1 = dn;
    fn1 = fn;
    gn1 = gn;
    float hn = fn - gn;
    // Store the reading in the array and update the sum
    readings[readingsIndex] = xn;
    sumReadings += xn;

    readings[readingsIndex1] = hn;
    sumReadings1 += hn;
    // Increment the sample read count and the readings index
    samplesRead++;
    readingsIndex++;

    samplesRead1++;
    readingsIndex1++;
    if (readingsIndex >= numReadings) {
      // Calculate the moving average
      float average1 = sumReadings / numReadings;
      float average2 = sumReadings1 / numReadings; 

      // Print the averaged sample
      Serial.print(average1);
      Serial.print(",");
      Serial.print(average2);

      Serial.println();

      // Reset the sum and readings index
      sumReadings = 0.0;
      readingsIndex = 0;
      sumReadings1 = 0.0;
      readingsIndex1 = 0;
    }

    if (samplesRead == numSamples) {
      // Add an empty line if it's the last sample
      Serial.println();
    }
  }
}
